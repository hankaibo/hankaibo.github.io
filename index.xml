<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>韩凯波的个人博客</title>
    <link>https://hankaibo.github.io/</link>
    <description>Recent content on 韩凯波的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 07 Aug 2019 20:52:35 +0800</lastBuildDate>
    
        <atom:link href="https://hankaibo.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Windows 10家庭版启用远程桌面连接</title>
      <link>https://hankaibo.github.io/post/2019/2019-08-07/</link>
      <pubDate>Wed, 07 Aug 2019 20:52:35 +0800</pubDate>
      
      <guid>https://hankaibo.github.io/post/2019/2019-08-07/</guid>
      
        <description>&lt;p&gt;一直没怎么用过Windows自带的远程桌面功能，最近经常需要在家远程连接公司电脑办公，但以前使用正常的Teamviewer突然抽风不能用了。&lt;/p&gt;

&lt;p&gt;即使同事给我使用了破解版本，也很快又出现了问题，可能是我打开的姿势不对吧！&lt;/p&gt;

&lt;p&gt;考虑到国人的尿性，直接决定使用国外软件（感觉自己有点崇洋媚外），查找了一晚上，最后找到两种办法。&lt;/p&gt;

&lt;p&gt;一，使用frp搭建反向代理服务器，通过外网借助系统自带的远程桌面功能连接内网电脑，具体请看此文。&lt;/p&gt;

&lt;p&gt;二，使用OpenVPN搭建服务器，借助远程桌面功能连接。&lt;/p&gt;

&lt;p&gt;以上两种实现方式，都要借助系统自带的功能，兴冲冲去启用该功能时发现自己是家庭版本。泪奔。&lt;/p&gt;

&lt;p&gt;问谷歌，只需借助一个小玩意即可实现。即&lt;a href=&#34;https://github.com/stascorp/rdpwrap&#34;&gt;RDP Wrapper Library&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;使用如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载最新版本:&lt;a href=&#34;https://github.com/stascorp/rdpwrap/releases&#34;&gt;https://github.com/stascorp/rdpwrap/releases&lt;/a&gt;；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解压之后安装：运行 install.bat 批处理文件；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置启用远程连接功能：运行 RDPConf.exe ，如果 Diagnostics 出现&lt;font color=red&gt;not listening [not supported]&lt;/font&gt;，说明不支持你的版本，继续看下文；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在网上找 rdpwrap.ini 的最新文件，下载之后替换掉 C:\Program Files\RDP Wrapper 目录下的同名文件。
比如这个 issue 里就有 &lt;a href=&#34;https://github.com/stascorp/rdpwrap/pull/816&#34;&gt;https://github.com/stascorp/rdpwrap/pull/816&lt;/a&gt;；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重新执行步骤3，全绿，表示通过；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行 RDPCheck.exe，连接电脑测试。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注： 如果一切正常的情况下依然不能连接可以尝试设置用户名/密码，无密码可能会出问题；&lt;/strong&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>前端路由</title>
      <link>https://hankaibo.github.io/post/2019/2019-04-08/</link>
      <pubDate>Mon, 08 Apr 2019 16:02:31 +0800</pubDate>
      
      <guid>https://hankaibo.github.io/post/2019/2019-04-08/</guid>
      
        <description>

&lt;h3 id=&#34;背景&#34;&gt;背景&lt;/h3&gt;

&lt;p&gt;说起前端路由，就不得再问一句有后台路由吗？
其实一开始是没有前端路由这个概念的，路由全部由后台服务器实现与控制。
当我们在浏览器地址栏中输入一个URL时，浏览器将其发送到后台服务器，服务器解析出地址并根据相关配置拼接成html返回给浏览器渲染。&lt;/p&gt;

&lt;p&gt;我们以常用的Spring MVC为例，后台服务器配置片段如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;bean class=&amp;quot;org.springframework.web.servlet.view.InternalResourceViewResolver&amp;quot;
    p:viewClass=&amp;quot;org.springframework.web.servlet.view.JstlView&amp;quot;
    p:prefix=&amp;quot;/WEB-INF/jsp/&amp;quot; p:suffix=&amp;quot;.jsp&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面我们配置了页面前缀prefix为“/WEB-INF/jsp/”，后缀suffix为“.jsp”。
当我们访问“&lt;a href=&#34;http://localhost:8000/users/toList”时，&#34;&gt;http://localhost:8000/users/toList”时，&lt;/a&gt;
后台将分解出“/users/toList”路径，并找到相关的Controller处理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Controller
@RequestMapping(value = &amp;quot;/users&amp;quot;)   //所有&amp;quot;/users&amp;quot;开头的url都被这个类处理。
public class BaseUserController {
    ...
    // &amp;quot;/users/toList&amp;quot;被这个方法处理。
    @RequestMapping(value = &amp;quot;/toList&amp;quot;, method = RequestMethod.GET)  
    public String toList() {
        return &amp;quot;user/list&amp;quot;;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此方法返回字符串“user/list”，再加上我们的前后缀prefix与suffix，即可得到“/WEB-INF/jsp/user/list.jsp”为我们返回给前端的页面。&lt;/p&gt;

&lt;p&gt;页面目录结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hankaibo.github.io/img/user_list.jpg&#34; alt=&#34;用户列表&#34; title=&#34;用户列表&#34; /&gt;&lt;/p&gt;

&lt;p&gt;按照返回的“/WEB-INF/jsp/user/list.jsp”，从上图中依次找到相应的页面给前端就完成了后台路由的处理。&lt;/p&gt;

&lt;p&gt;通过上面的示例，我们了解了后台路由的处理流程。&lt;/p&gt;

&lt;p&gt;为什么会出现前端路由呢？&lt;/p&gt;

&lt;p&gt;从上面的流程中，我们不难发现，不同的url对应着不同的页面，当我们切换url时，浏览器会切换对应的页面，它是整体替换的。页面会出现闪烁刷新，导致用户体验不够好。
Google将Ajax发扬光大后，异步的局部刷新流行开来，但Ajax的无浏览历史记录导致浏览器的前进后退处理比较麻烦，这种情况下，用前端路由就可以很好的解决。
再加上单页面应用与MVVM的发展，前端路由逐渐成熟与流行起来。&lt;/p&gt;

&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;

&lt;p&gt;要实现前端路由，就要解决两个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在页面不刷新的前提下实现url变化&lt;/li&gt;
&lt;li&gt;捕捉到url的变化，以便执行页面替换逻辑&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两个问题都可以通过如下技术解决。一种是基于URL的frag(片段)技术，以“#”为标示，一种是基于HTML 5的History API。即：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;location.hash+hashchange事件&lt;/li&gt;
&lt;li&gt;history.pushState()+popState事件&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;hash方式&#34;&gt;hash方式&lt;/h5&gt;

&lt;p&gt;根据URL协议我们知道，服务器通常只处理整个对象，而不处理片段，浏览器不能将片段传送给服务器。浏览器从服务器获取整个资源之后，会根据片段来显示指定的资源。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当我们访问“&lt;a href=&#34;http://localhost:8000/”时，我们首先打开了默认的index.html页面；&#34;&gt;http://localhost:8000/”时，我们首先打开了默认的index.html页面；&lt;/a&gt;
然后我们被重定向到一个新地址，比如：“&lt;a href=&#34;http://localhost:8000/#/index”；&#34;&gt;http://localhost:8000/#/index”；&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;当我们访问用户列表时，通过页面location.hash事件触发，我们的URL变成“&lt;a href=&#34;http://localhost:8000/#/users/list”，根据URL协议，#之后的内容不会发送给服务器，&#34;&gt;http://localhost:8000/#/users/list”，根据URL协议，#之后的内容不会发送给服务器，&lt;/a&gt;
对后台来说URL未变不需要它实现路由了，我们通过hashchange事件监听url变化，发送ajax请求向后台请求数据局部刷新页面，实现了页面的正确加载显示。&lt;/li&gt;
&lt;li&gt;当我们访问其它页面时，比如部门列表时，就变成了“&lt;a href=&#34;http://localhost:8000/#/depts/list”，同理。&#34;&gt;http://localhost:8000/#/depts/list”，同理。&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过上面的分析，我们实现了路由控制从后台向前端的转移，并同样完成了页面的正确加载显示。&lt;/p&gt;

&lt;h5 id=&#34;history方式&#34;&gt;history方式&lt;/h5&gt;

&lt;p&gt;这是HTML 5新增的方式，它可以在不刷新页面的前提下动态改变浏览器地址栏中的URL地址，动态修改页面上所显示资源。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当我们访问“&lt;a href=&#34;http://localhost:8000/”时，我们首先打开了默认的index.html页面；然后我们被重定向到一个新地址，&#34;&gt;http://localhost:8000/”时，我们首先打开了默认的index.html页面；然后我们被重定向到一个新地址，&lt;/a&gt;
比如：“&lt;a href=&#34;http://localhost:8000/index”；&#34;&gt;http://localhost:8000/index”；&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;当我们访问用户列表时，通过页面history.pushState()事件触发，我们的URL变成“&lt;a href=&#34;http://localhost:8000/users/list”，根据history&#34;&gt;http://localhost:8000/users/list”，根据history&lt;/a&gt; API的实现，我们会修改地址栏的地址，但不会
向后台发送请求，再通过popState事件监听到了url的变化，发送ajax请求向后台请求数据之后局部刷新页面。&lt;/li&gt;
&lt;li&gt;当我们访问其它页面时，也是同样的原理。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两种方式的优缺点网上有很多，我就不再啰嗦了。&lt;/p&gt;

&lt;h3 id=&#34;404问题&#34;&gt;404问题&lt;/h3&gt;

&lt;p&gt;前后端分离的单页应用，我们使用history方式，开开心心地build完代码扔给后台部署之后一切正常。但测试人员反应，一旦刷新，就会报404的错误。
比如，我们在页面“&lt;a href=&#34;http://localhost:8000/users/list”F5刷新时，就报了404错误。但我们本地开发一切正常啊？&#34;&gt;http://localhost:8000/users/list”F5刷新时，就报了404错误。但我们本地开发一切正常啊？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这是怎么会事呢？&lt;/p&gt;

&lt;p&gt;因为使用history模式的路由中，路由是虚拟的，后台并不存在相应的物理路径和文件。
比如，当刷新页面时，浏览器会向服务器请求/users/list，服务器实际会去找根目录下/users/list.html这个文件，发现找不到，
因为实际上我们的服务器并没有这样的物理路径/文件，所有内容都是通过Restful风格的接口返回数据通过前端自己渲染的，自然会报404错误。
而开发时，内置的服务器已经帮我们做了处理，我们当然发现不了。&lt;/p&gt;

&lt;p&gt;要解决这个问题也很简单，只要将所有请求到统一转发到首页，利用首页加载的js解析地址栏路由动态请求数据刷新页面完成显示。&lt;/p&gt;

&lt;p&gt;比如nginx这样配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;try_files $url /index.html
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>前端简史</title>
      <link>https://hankaibo.github.io/post/2019/2019-03-06/</link>
      <pubDate>Wed, 06 Mar 2019 13:57:46 +0800</pubDate>
      
      <guid>https://hankaibo.github.io/post/2019/2019-03-06/</guid>
      
        <description>

&lt;h2 id=&#34;html&#34;&gt;HTML&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;1993.06，HTML诞生&lt;/li&gt;
&lt;li&gt;1995.11，HTML 2.0&lt;/li&gt;
&lt;li&gt;1996.01，HTML 3.2&lt;/li&gt;
&lt;li&gt;1997.11，HTML 4.0&lt;/li&gt;
&lt;li&gt;2014.10，HTML 5.0&lt;/li&gt;
&lt;li&gt;2017.10，HTML 5.1&lt;/li&gt;
&lt;li&gt;2017.12，HTML 5.2&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;css&#34;&gt;CSS&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;1996.12, CSS 1.0&lt;/li&gt;
&lt;li&gt;1998.05, CSS 2.0&lt;/li&gt;
&lt;li&gt;2001.05, CSS 3.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;javascript&#34;&gt;JavaScript&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;1995, LiveScript ==&amp;gt; JavaScript&lt;/li&gt;
&lt;li&gt;1996, JScript&lt;/li&gt;
&lt;li&gt;1997, ECMAScript&lt;/li&gt;
&lt;li&gt;1990s, ECMAScript 1.0 &amp;ndash;&amp;gt; 2.0 &amp;ndash;&amp;gt; 3.0&lt;/li&gt;
&lt;li&gt;2007s, ECMAScript 4.0 &amp;ndash;&amp;gt; 3.1&lt;/li&gt;
&lt;li&gt;2009s, ECMAScript 5.0 &amp;ndash;&amp;gt; 5.1&lt;/li&gt;
&lt;li&gt;2015, ECMAScript 6.0 ==&amp;gt; ECMAScript 2015&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;web-1-0时代-静态页面&#34;&gt;Web 1.0时代，静态页面&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;1990, WWW诞生&lt;/li&gt;
&lt;li&gt;1992, Mosaic&lt;/li&gt;
&lt;li&gt;1994, Navigator 1.0&lt;/li&gt;
&lt;li&gt;1996, Navigator 2.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;web-2-0时代-动态页面&#34;&gt;Web 2.0时代，动态页面&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Ajax&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2004, Google Email&lt;/li&gt;
&lt;li&gt;2005, Google Map
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;兼容性&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dojo&lt;/li&gt;
&lt;li&gt;jQuery&lt;/li&gt;
&lt;li&gt;MooTools&lt;/li&gt;
&lt;li&gt;Prototype&lt;/li&gt;
&lt;li&gt;YUI/Ext
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模块化&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CommonJS&lt;/li&gt;
&lt;li&gt;AMD&lt;/li&gt;
&lt;li&gt;CMD&lt;/li&gt;
&lt;li&gt;UMD
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模板&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aiduTemplate&lt;/li&gt;
&lt;li&gt;artTemplate&lt;/li&gt;
&lt;li&gt;juicer&lt;/li&gt;
&lt;li&gt;&amp;hellip;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;MVVM&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Knockout&lt;/li&gt;
&lt;li&gt;Backbone&lt;/li&gt;
&lt;li&gt;Angular&lt;/li&gt;
&lt;li&gt;React&lt;/li&gt;
&lt;li&gt;Vue&lt;/li&gt;
&lt;li&gt;&amp;hellip;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;node-js-诞生-大前端时代&#34;&gt;Node.js 诞生，大前端时代&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;bower&lt;/li&gt;
&lt;li&gt;npm&lt;/li&gt;
&lt;li&gt;jspm&lt;/li&gt;
&lt;li&gt;spm&lt;/li&gt;
&lt;li&gt;grunt&lt;/li&gt;
&lt;li&gt;gulp&lt;/li&gt;
&lt;li&gt;webpack&lt;/li&gt;
&lt;li&gt;rollup&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Hello</title>
      <link>https://hankaibo.github.io/post/hello/</link>
      <pubDate>Thu, 31 Jan 2019 11:45:23 +0800</pubDate>
      
      <guid>https://hankaibo.github.io/post/hello/</guid>
      
        <description>&lt;p&gt;Hi, hugo!&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://hankaibo.github.io/about/</link>
      <pubDate>Wed, 30 Jan 2019 16:32:08 +0800</pubDate>
      
      <guid>https://hankaibo.github.io/about/</guid>
      
        <description>&lt;p&gt;我是一条狗。&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>